\documentclass[10pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{syntax} % Grammar writer %
\usepackage{listings} % source code writer %
\usepackage[usenames,dvipsnames]{xcolor}

% ----------------------------------------------------------
% Source code syntax highlight
\lstdefinelanguage{Emma}
{morekeywords={print,if,else,while,def,return,for,continue,break,class,null},
sensitive=false,
morecomment=[l]{\#},
morestring=[b]",
morestring=[b]',
} 

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Emma,
  emph={and,xor,or,not},
  emphstyle=\color{Sepia},
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=fixed,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
% End of syntax highlight
% ----------------------------------------------------------

\author{Yang Wang}
\title{The Emma Language Reference}
\begin{document}
%\maketitle

\section{Introduction}
This reference manual describes the Emma language and also serves as a  
language specification and development guidance.

The Emma language is a self-education and experimental project. 
The main purpose is for the author to study the theory and best practice related
to compiler design and implementation. 
The final product is envisioned to be a high level programming language similar
to Python in spirit, but also incorporate features from other languages such as
IDL (Interactive Data Language), C, Java. 

The basic target of the language is to be Turning complete. The ultimate
target is to be self-hosting, i.e.\ be able to compile itself.
The current development scope of the language is listed as follows:

\begin{itemize}
\item Functions (with recursive calls)
\item Array support
\item Basic I/O support
\item Object oriented programming support by Class definitions
\item Error handling and interactive debugging similar to IDL
\end{itemize}


\subsection{Implementation}
The language will be prototyped in Python and implemented in C. 
An interactive environment will be provided as well as a batch
run mode. Any programs written in the language will be compiled
to bytecode to boost the execution speed. This means
that a runtime environment of the Emma language is always required to run
the bytecode, since it will not be compiled down to the native machine
code.

\pagebreak

\section{Lexical analysis}
\subsection{Line structure}
An Emma program is consisted of lines of texts. The line structure is
hence one of the basic component of a source program.

\subsubsection{Physical lines}
A physical line is terminated by an end-of-line sequence (EOL). The
sequence is different on different platforms. Unix and alike use ASCII LF
(linefeed), while Windows uses ASCII sequence of CR LF (carriage return followed
by a linefeed). All of these sequences are treated equally as a single 
EOL symbol.

\subsubsection{Logical lines}
A logical line can be a single physical line, multiple physical lines, or
part of a single physical line.

A logical line is terminated by either a EOL or a semicolon if the last
statement is a simple one. A compound statement always has a ``\}'' at 
the end, which can also serve as a logical line termination.

Termination of a logical line by a EOL is the most straightforward choice. 
This makes a physical line to be also a logical line.

A semicolon is supposed to be used in the middle of a physical line to separate 
statements. This allows a single physical line to contain multiple logical
lines, which is useful to enter a long script in an interactive session.

While termination by a semicolon is final, termination by a EOL can be 
suppressed explicitly by a line continuation symbol, ``\textbackslash".
The line continuation symbol, ``\textbackslash", joins two lines
by removing the EOL symbol between them.
This makes it possible to have a logical line span across multiple 
physical lines. 

Simple statements can never cross the boundaries of a logical line.
For compound statements, the language syntax allows both EOL and semicolon
to be in between statements in a ``\{\}'' pair. Therefore compound statements
may be consisted of multiple logical lines. Note that even for a compound 
statement, line termination is still not allowed outside of the 
``\{\}'' pair. 

These rules are better clarified with the following example:

\begin{lstlisting}
# Line termination rules
if (x == 1) {
    y = 1;
} else {
    y = 0
} a = 5; b = 6
\end{lstlisting}

Note that both EOL and semicolon can appear inside the ``\{\}'' pairs. 
But lines cannot be terminated outside of the ``\{\}'' pairs. That is
why the ``\{'' has to be in the same line with ``\lstinline$if (x == 1)$''.
Similarly, ``\lstinline$else$'' is in the same line with both the leading
``\}'' and the ending ``\{''. Also note that ``\lstinline$a = 5$'' does
not need a semicolon before it because the previous compound statement
is properly terminated by a ``\}''. In contrast, a semicolon is needed
after it for the following ``\lstinline$b = 6$''.

\subsubsection{Line joining}
The backslash character, ``\textbackslash'', can be used to join two lines 
separated by EOL.
This allows a logical line to span across multiple physical lines as follows:
\begin{lstlisting}
# Line joining by "\" character
x = a + b \
      + c \
      + d
\end{lstlisting}

\subsubsection{Comment}
The hash character, ``\#'', starts a single line comment that runs to the end
of a physical line. There is currently no plan to support multi-line
comment symbols.

\subsubsection{Empty line and whitespace}
Any empty line and whitespace are not part of the Emma language. They are
effectively ignored.

\subsection{Keywords and identifiers}
Keywords are reserved and listed as follows\footnote{Keyword operators are shown in sepia color while normal keywords are shown in blue. It is completely cosmetic with no impact on the language.}:
\begin{lstlisting}
print if else while for continue break def return null class 
and or xor 
\end{lstlisting}

An identifier is a character sequence starts with a letter or an underscore 
and followed by zero or more letters, numbers or underscore and it cannot
be any of the reserved keywords.

\subsubsection{Speical identifier}
A special identifier, ``_'' (without the quotes), always points
to the value of last unused expression.
\begin{lstlisting}
# Speical identifier
1 + 1
a = 2 + 2
print 3 + 3
\end{lstlisting}
At the end of the above code snippet, the value of ``_'' is 2. This is because 
both \lstinline$2 + 2$ and \lstinline$3 + 3$ are used by an assignment and
a print statement, respectively. User can directly assign value to the special
identifier. In doing so, any value it holds previously is overwritten.

\subsection{Number}
Numbers come in only two types, integer and floating point numbers.
Both numbers can be arbitrary large as long as the computer memory
can hold them. Only decimal numbers are supported. Floating point
number can be written in scientific notation form, e.g. 1.0e+20.

\subsection{Operators}
Certain keywords are also operators, such as \lstinline$and$, 
\lstinline$or$, \lstinline$xor$, \lstinline$not$. Other operators
includes mathematical operators and symbols for aiding formation
of language structs. They are show as follows:
\begin{lstlisting}
+ - * / % ** ( ) { } [ ] , : ;
\end{lstlisting}
Note that the unprintable EOL symbol is not shown in the above list,
though it is also an operator. 


\subsection{Tokens}
Tokens are recognized and returned by a lexer. A token can be a keyword,
an identifier, a number or an operator. The token definitions are listed
as follows:

\begin{verbatim}
IDENT       ::= (Letter| Underscore) 
                    (Letter | Digit | Underscore)*

STRING      ::= "" | ''

KEYWORD     ::= print | if | else | for | while | continue 
              | break | def | class | and | or | xor | not
              
NUMBER      ::= [+ | -] Pos_Number

Pos_Number  ::= [0-9]+ 
              | [0-9]* . [0-9]+ [Expo] 
              | [0-9]+ . [0-9]* [Expo]

Expo        ::= e [+ | -] [0-9]+
\end{verbatim}

Note that only full capitalized words are tokens. Camel case words
are only here to aid reading and clarity. 
Space and tab are both WHITE and ignored. Operators and other characters
are returned as tokens named by their lexme.

\pagebreak


\section{Syntax analysis}
\subsection{grammar}
The grammar is of LL(1) class to facilitate a hand written predictive recursive
descendant parser. A LL(1) grammar has following requirements:

The BNF forms of the grammar are shown as follows:

\setlength{\grammarparsep}{10pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS 
\begin{grammar}

% We could let lexer to do more work on merge consecutive ';' as a single ';'

<program> ::= <statement>*

<statement> ::= "EOL" 
    \alt <stmt_list> "EOL"

<stmt_list> ::= [`;'] <simple_stmt_list> | <compound_stmt_list>

<simple_stmt_list> ::= <simple_stmt> [ `;' <list_rest> ]

<compound_stmt_list> ::= <compound_stmt> [ <list_rest> ]

<list_rest> ::= <smiple_stmt_list> 
    \alt <compound_stmt_list>

<stmt> ::= <simple_stmt> 
    \alt <compound_stmt> 
    \alt <stmt_block>

<stmt_block> ::= `{' <statement>* [<stmt_list>] "EOL"* `}'

<compound_stmt> ::= <if_stmt>
	\alt <while_stmt>
	\alt <for_stmt>
	\alt <funcdef>
    \alt <classdef>
	
<if_stmt> ::= `if' <expression> <stmt> [`else' <stmt>]
              
<while_stmt> ::= `while' <expression> <stmt>

<for_stmt> ::= `for' "IDENT" `=' <expression>, <expression> [`,' <expression>] <stmt>

<oparm_list> ::= <oparm> (`,' <oparm>)*

<oparm> ::= <kvpair> | "IDENT"

<parmlist> ::= <oparm_list> [`,' `*' "IDENT"] [`,' `**' "IDENT"]
    \alt `*' "IDENT" [`,' `**' "IDENT"]
    \alt `**' "IDENT"

<funcdef> ::= `def' "IDENT" `(' [<parmlist>] `)' <stmt_block>

<classdef> ::= `class' "IDENT" `(' "IDENT" `)' <stmt_block>

<simple_stmt> ::= <expression>
	\alt <assign_stmt>                    
	\alt <print_stmt>
	\alt `continue'
	\alt `break'
	\alt `return' <expression>
	
<print_stmt> ::= `print' [expression (`,' <expression>)*]

<target> ::= "IDENT" | <dotname> | <slice>

<assign_stmt> ::= <target> `=' <expression>

<expression> ::= <r_expr>

<r_expr> ::= <r_term> (<r_orop> <r_term>)*

<r_term> ::= <r_factor> (<r_andop> <r_factor>)*

<r_factor> ::= [`not'] <l_expression>

<l_expr> ::= <a_expr> (<l_op> <a_expr>)*

<a_expr> ::= <a_term> (<addop> <a_term>)*

<a_term> ::= <u_expr> (<mulop> <u_expr>)*

<u_expr> ::= [<unary_op>] <power>

<power> ::= <factor> [`**' <u_expr>]

<literal> ::= "STRING" | "NUMBER" | "NULL"

<factor> ::= <primary> | <literal> | `(' <expression> `)'

<kvpair> ::= "IDENT" `=' <expression>

<oarg> ::= <kvpair> | <expression>

<arglist> ::= <oarg> (`,' <oarg>)*

<call> ::= <primary> `(' [<arglist>] `)'

<idxlist> ::= <singleidx> (`,' <expression>)*

<long_idxrange> ::= <short_idxrange> `:' [<expression>]

<short_idxrange> ::= <singleidx> `:' [<expression>] 

<single_idx> ::= <expression>

<slice> ::= <primary> `[' single_idx \alt short_idxrange \alt long_idxrange \alt idxlist `]'

<dotname> ::= <primary> (`.' "IDENT")+

<primary> ::= "IDENT" | <dotname> | <slice> | <call>


\end{grammar}

% <r_orop> ::= `or' | `xor'
% <r_andop> ::= `and'
% <l_op> ::= `>' | `<' | `>=' | `<=' | `==' | `!='
% <addop> ::= `+' | `-'
% <mulop> ::= `*' | `/' | `%'


\pagebreak

\section{Intermediate representation}

\pagebreak

\section{Virtual machine}

\pagebreak

\section{Standard library}


\end{document}
